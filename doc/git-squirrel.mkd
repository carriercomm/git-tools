# F=git-squirrel squirrel away files and notes

[[TOC]]

## why

Here are my two most common uses for this:

  * I have plenty of files that I probably don't need again, but don't dare to
    delete *right now*.  Since cleaning up the hard disk is a chore, I never
    get around to doing it *later* and they hang around pretty much forever.

  * A lot of artifacts at work are ODT/ODS/ODP, and I don't like using normal
    git workflows with them due to merge issues.  Since the buck stops with me
    on these docs, I simply choose to save them everyday using this mechanism.

You can do most of the above with normal directories (except the part about
versioning LibreOffice files), but I think having the files directly on disk
is ugly and messy, not to mention too "in your face", for stuff you may never
need.

<font color="gray">A word about email: if *all* your work items come via
email, it is certainly feasible to use the mail client itself to do all this.
My problem is there is so much *more* junk (junk != spam, please note) on
email, it slows down everything else.  There are dozens of attachments I don't
even open, for instance.  With squirrel, I am only dealing with content that I
at least had a passing interest in, and which has been on my hard disk, *other
than* just sitting in my email, at some point.</font>

I want to

  * reduce clutter on my file system
  * save arbitrary files in some categorised fashion
  * save multiple revisions of the same file at regular intervals
  * record accurately when they were saved (Unix timestamps are too fragile)
  * allow me to delete them en-masse if needed
  * get automatic de-dup for similar content
  * get "better-than-unison" syncing between computers

`git squirrel` is a tool to manage your own special "dump everything here" git
repository.

## cautions

  * the repo should NOT be bare.  This *is* a work repo, except you're using
    it via a special program.

    For example, I have an equivalent repo on my other machines, and manual
    syncs involve the usual push/pull between one central -- bare -- repo and
    each of the work repos on different machines.

    In other words, exactly the same as any other "working repo".

  * for the same reasons, do not run one squirrel command when another one is
    pending.  They both use the same repo/working tree!

  * dont use it for files that are too large; this isn't anything
    significantly different from other git repos.  This is not git-annexe or
    bup :-)

## syntax

**TIP**: The `--repo` option is, umm, not an option.  I have this in my
`~/.gitconfig` so my commands are just `git z ...`:

    [alias]
        z   =   squirrel --repo=/home/sitaram/imli/repos/squirrel

That is what **all** the examples in this document will assume.

Don't forget you're supposed to have *one* squirrel repo for your whole
machine (otherwise you're back to square one searching for files!)

**TIP**: Sometimes you will need a '--' to separate options from arguments, as
you can see in some of the examples below.

### note on branch and filenames

  * If a branch name begins with a `/`, the rest of that word is taken to be a
    pattern to be regex-matched against all known branch names.

    Where only one match is required or reasonable, the **last** match, in
    sorted order, is picked; it is not an error that more matches exist.

  * The same logic holds for filenames, except that *all* the matching
    filenames are picked, not just one.

### view the current repo

arguments: list of branch names or patterns

    git z -v                            # gitk, all branches
    git z -v tig                        # tig, all branches
    git z -v -- /foo bar                # gitk, branches bar and any branch
                                        # containing 'foo' in the name

Squirrel adds a `--date-order` to the viewer's arguments for convenience.

### list branches and/or files

arguments: one branch name or pattern, followed by optional list of file names
or patterns

    git z -l /foo                       # list all branches containing 'foo' in the name
    git z -l /foo /gl                   # list all files containing 'gl' in the name from
                                        # within all branches containing 'foo' in the name
    git z -l /foo /pdf /jpg             # list all jpgs and pdfs in all
                                        # branches containing 'foo' in the
                                        # name
    git z -l 2011/misc mypic.jpg        # list a specific file in a specific branch

### edit files directly and save back

This works only for text files, and uses `$VISUAL`, then `$EDITOR`, falling
back to `vim` if none of these are set.

arguments: one branch name or pattern, followed by optional list of file
patterns (actual filenames not allowed here), followed by an optional list of
words to search *within* the files.  These words are processed as arguments to
'git grep' except we choose a default of --and, not --or.

The branch name will be created if it is not a pattern and does not already
exist.

This is an interesting command.  I suggest you don't use it until I figure out
where I'm going with it, but if you have to, give it a whirl :-)

### save files

arguments: one branch name/pattern, optional "commit message", list of
files/directories to save

The branch name will be created if it is not a pattern and does not already
exist.  The optional commit message must not have the same name as a file or a
directory in the original directory.

    git z -s bills/2012 *-payment.jpg   # save all the screenshot to bills/2012

    git z -s /bills     *-payment.jpg   # same, assuming bills/2012 is the last
                                        # of the matching branches in sort order

    git z -s reviews/2011 "first round of reviews" [...files...]
                                        # add a "commit message"; see tips
                                        # section later for why this may useful

    git z -s reviews/2011 papers/*.pdf reviews/*.ods
                                        # run such a command regularly to save
                                        # w-i-p; only changes will go through,
                                        # just like normal git

Note: just like normal git, don't use this with huge binaries etc.; use
git-annex or something for those).

### restore files

arguments: one branchname/pattern, followed by an optional list of file names
or patterns.

NOTE: restores to /tmp by default

    git z -r /reviews /access           # restore all files containing
                                        # 'access' in their names from the
                                        # last (in sorted order) branch whose
                                        # name contains 'reviews'

    git z -r /reviews                   # same, but restore all the files in
                                        # the branch

    git z -r=. /reviews                 # same, but restore to $PWD

    git z -r --cm='first' /reviews      # see notes below

The commit match (--cm) option does a regex search on the output of `git log
--date-order --oneline` after checking out the given branch.  The first SHA
found is used.
